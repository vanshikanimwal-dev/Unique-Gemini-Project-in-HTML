<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gesture Particles: Fireworks Edition</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        #info {
            position: absolute; top: 20px; left: 20px; color: #0ff;
            background: rgba(0,0,0,0.7); padding: 15px; border-radius: 8px;
            border: 1px solid #0ff; pointer-events: none; line-height: 1.5;
        }
        video { transform: scaleX(-1); position: absolute; width: 180px; bottom: 20px; right: 20px; border-radius: 10px; opacity: 0.6; }
    </style>
</head>
<body>

    <div id="info">
        <b>HAND COMMANDS:</b><br>
        ✨ <b>Move:</b> Follows Index Finger<br>
        ↔️ <b>Pinch/Spread:</b> Scale Shape<br>
        ✌️ <b>Two Fingers:</b> Switch Shape<br>
        ✊ <b>Make Fist:</b> FIREWORKS!
    </div>
    
    <video id="webcam" autoplay playsinline></video>

    <script src="https://cdn.jsdelivr.net/npm/three@0.152.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

    <script>
        const videoElement = document.getElementById('webcam');
        const count = 8000; 
        let currentShape = 'sphere';
        let targetScale = 1;
        let isExploding = false;

        // --- THREE.JS SETUP ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 8;
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const geo = new THREE.BufferGeometry();
        const pos = new Float32Array(count * 3);
        const targetPos = new Float32Array(count * 3);
        const velocities = new Float32Array(count * 3);
        const colors = new Float32Array(count * 3);

        for (let i = 0; i < count; i++) {
            pos[i*3] = (Math.random()-0.5)*20;
            pos[i*3+1] = (Math.random()-0.5)*20;
            pos[i*3+2] = (Math.random()-0.5)*20;
        }

        geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
        geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));

        const mat = new THREE.PointsMaterial({ size: 0.035, vertexColors: true, blending: THREE.AdditiveBlending, transparent: true });
        const points = new THREE.Points(geo, mat);
        scene.add(points);

        // --- SHAPE LOGIC ---
        function setShape(type) {
            currentShape = type;
            for (let i = 0; i < count; i++) {
                let x, y, z;
                const t = Math.random() * Math.PI * 2;
                const u = Math.random() * Math.PI * 2;
                if (type === 'heart') {
                    const v = Math.random() * Math.PI * 2;
                    x = 1.6 * Math.pow(Math.sin(v), 3);
                    y = 1.3 * Math.cos(v) - 0.5 * Math.cos(2*v) - 0.2 * Math.cos(3*v) - 0.1 * Math.cos(4*v);
                    z = (Math.random() - 0.5) * 0.5;
                } else if (type === 'saturn') {
                    if (i < count * 0.7) {
                        x = Math.cos(t)*Math.sin(u); y = Math.sin(t)*Math.sin(u); z = Math.cos(u);
                    } else {
                        const r = 2.5 + Math.random() * 0.8;
                        x = Math.cos(t) * r; y = Math.sin(t) * r; z = (Math.random()-0.5)*0.1;
                    }
                } else { // Sphere
                    x = Math.cos(t)*Math.sin(u)*2; y = Math.sin(t)*Math.sin(u)*2; z = Math.cos(u)*2;
                }
                targetPos[i*3] = x; targetPos[i*3+1] = y; targetPos[i*3+2] = z;
            }
        }
        setShape('sphere');

        function triggerExplosion() {
            if (isExploding) return;
            isExploding = true;
            for (let i = 0; i < count; i++) {
                velocities[i*3] = (Math.random() - 0.5) * 0.5;
                velocities[i*3+1] = (Math.random() - 0.5) * 0.5;
                velocities[i*3+2] = (Math.random() - 0.5) * 0.5;
            }
            setTimeout(() => { isExploding = false; }, 800);
        }

        // --- HAND TRACKING ---
        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.6, minTrackingConfidence: 0.6 });
        
        hands.onResults((results) => {
            if (results.multiHandLandmarks && results.multiHandLandmarks[0]) {
                const landmarks = results.multiHandLandmarks[0];
                
                // Position Follow
                points.position.x = (0.5 - landmarks[8].x) * 15;
                points.position.y = (0.5 - landmarks[8].y) * 10;

                // Scale Logic
                const dist = Math.hypot(landmarks[8].x - landmarks[4].x, landmarks[8].y - landmarks[4].y);
                targetScale = dist * 10;

                // Gesture Detection
                const isIndexUp = landmarks[8].y < landmarks[6].y;
                const isMiddleUp = landmarks[12].y < landmarks[10].y;
                const isRingUp = landmarks[16].y < landmarks[14].y;

                if (!isIndexUp && !isMiddleUp && !isRingUp) {
                    triggerExplosion();
                } else if (isIndexUp && isMiddleUp && !isRingUp) {
                    // Quick cycle shapes if two fingers are up
                    if (Math.random() > 0.95) setShape(currentShape === 'sphere' ? 'heart' : currentShape === 'heart' ? 'saturn' : 'sphere');
                }
            }
        });

        new Camera(videoElement, { onFrame: async () => { await hands.send({image: videoElement}); }, width: 640, height: 480 }).start();

        // --- RENDER LOOP ---
        function animate() {
            requestAnimationFrame(animate);
            const positions = geo.attributes.position.array;
            const colorArr = geo.attributes.color.array;

            for (let i = 0; i < count; i++) {
                if (isExploding) {
                    positions[i*3] += velocities[i*3];
                    positions[i*3+1] += velocities[i*3+1];
                    positions[i*3+2] += velocities[i*3+2];
                    // Flash white during explosion
                    colorArr[i*3] = colorArr[i*3+1] = colorArr[i*3+2] = 1;
                } else {
                    // Smooth Morph to Shape
                    positions[i*3] += (targetPos[i*3] * targetScale - positions[i*3]) * 0.1;
                    positions[i*3+1] += (targetPos[i*3+1] * targetScale - positions[i*3+1]) * 0.1;
                    positions[i*3+2] += (targetPos[i*3+2] * targetScale - positions[i*3+2]) * 0.1;
                    
                    // Colors based on current shape
                    colorArr[i*3] = 0.2 + Math.abs(targetPos[i*3]); 
                    colorArr[i*3+1] = 0.4 + Math.sin(Date.now() * 0.001);
                    colorArr[i*3+2] = 1.0;
                }
            }

            geo.attributes.position.needsUpdate = true;
            geo.attributes.color.needsUpdate = true;
            points.rotation.y += 0.01;
            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>